# DRAIN.ME v0.1 - Simple Vault

## Goal (Цель v0.1)
Безопасное хранилище для ETH. Пользователи могут:
- Внести ETH в протокол
- Вывести свои средства когда захотят
- Проверить свой баланс

Это фундамент для будущего lending протокола.

## Long-term Vision


## Functions (v0.1)
1. **deposit()** external payable
   - Пользователь вносит ETH
   - Увеличивается deposits[msg.sender]
   - Увеличивается totalDeposits
   - Emit Deposited event

2. **withdraw(uint256 amount)** external
   - Пользователь выводит amount ETH
   - Проверка: deposits[msg.sender] >= amount
   - Уменьшается deposits[msg.sender]
   - Уменьшается totalDeposits
   - Отправка ETH через call{value}
   - Emit Withdrawn event

3. **getDeposit(address user)** external view returns (uint256)
   - Возвращает deposits[user]
   - Может вызвать любой для любого адреса

4. **getTotalDeposits()** external view returns (uint256)
   - Возвращает общую сумму депозитов в протоколе

## State Variables
```solidity
// User deposits tracking
mapping(address => uint256) public deposits;

// Total amount deposited in protocol
uint256 public totalDeposits;
```

## Events
```solidity
event Deposited(address indexed user, uint256 amount);
event Withdrawn(address indexed user, uint256 amount);
```

## Security Threats
1. **Reentrancy в withdraw:**
   - Проблема: Атакер вызывает withdraw → получает ETH → 
     в receive() снова вызывает withdraw
   - Решение: Checks-Effects-Interactions pattern
```solidity
     // 1. Checks
     require(deposits[msg.sender] >= amount);
     
     // 2. Effects (изменяем state ДО отправки ETH!)
     deposits[msg.sender] -= amount;
     totalDeposits -= amount;
     
     // 3. Interactions (отправка ETH в конце)
     (bool success, ) = msg.sender.call{value: amount}("");
     require(success);
```

2. **Integer overflow/underflow:**
   - Проблема: deposits[user] -= amount может underflow
   - Решение: Solidity 0.8+ автоматически проверяет ✅

3. **ETH застрял в контракте:**
   - Проблема: Кто-то отправляет ETH напрямую (не через deposit)
   - Решение v0.1: Игнорируем (не добавляем receive/fallback)
   - В v0.2: Можем добавить receive() если нужно

4. **Withdraw 0 amount:**
   - Проблема: Пустые транзакции тратят gas
   - Решение: `require(amount > 0, "Cannot withdraw 0")`

## Invariants (Должны ВСЕГДА быть true)
1. **contract.balance >= totalDeposits**
   - Контракт всегда имеет достаточно ETH для всех депозитов
   
2. **sum(all deposits[user]) == totalDeposits**
   - Учёт корректен

3. **deposits[user] >= 0** (всегда, благодаря Solidity 0.8+)

4. **После withdraw: deposits[user] уменьшился ровно на amount**

## Edge Cases (Крайние случаи)
- Пользователь вызывает withdraw(0) → должен revert
- Пользователь вызывает deposit{value: 0} → должен revert
- Пользователь пытается withdraw больше чем deposits → revert
- Несколько пользователей делают deposit/withdraw одновременно → 
  все должны работать корректно

## Out of Scope (НЕ в v0.1)
- ❌ Collateral deposits
- ❌ Borrowing/lending
- ❌ Interest rates calculation
- ❌ Health Factor
- ❌ Liquidations
- ❌ Multiple tokens (только ETH в v0.1)
- ❌ Flash loans
- ❌ Governance
- ❌ Upgradability

## Success Criteria (Как понять что v0.1 готова)
- ✅ Пользователи могут deposit ETH
- ✅ Пользователи могут withdraw свой ETH
- ✅ Балансы отслеживаются корректно
- ✅ Все тесты проходят (100% coverage)
- ✅ Нет reentrancy уязвимости
- ✅ Invariants выполняются всегда
- ✅ Code review пройден (я проверю)

## Testing Plan
Тесты которые нужно написать:
1. testDeposit - базовый deposit работает
2. testMultipleDeposits - несколько deposit суммируются
3. testWithdraw - базовый withdraw работает
4. testWithdrawAll - вывод всех средств
5. testCannotWithdrawMoreThanDeposit - revert если недостаточно
6. testCannotWithdrawZero - revert на withdraw(0)
7. testCannotDepositZero - revert на deposit{value: 0}
8. testMultipleUsers - разные юзеры, отдельные балансы
9. testTotalDepositsTracking - totalDeposits корректен
10. testReentrancyProtection - атака reentrancy не работает

## Next Version (v0.2 - Collateral System)
Что добавим:
- `depositCollateral()` - внести ETH как залог
- `withdrawCollateral()` - вывести залог (если не занимал)
- Разделение: `deposits` vs `collateral` mappings
- Новые events: `CollateralDeposited`, `CollateralWithdrawn`